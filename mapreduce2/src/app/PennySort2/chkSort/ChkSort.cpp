/***************************************************************************
***************************************************************************

Creator:    Peng Liu, Tsinghua University, Beijing, China
Email: pengliu@ieee.org    it_2001@china.com
http://hpclab.cs.tsinghua.edu.cn/~liupeng/

Date:   12/08/2002

****************************************************************************
****************************************************************************/

/*
ChkSort.EXE :  Verify the results of PennySort entrants

ChkSort will calculate and compare the checksums of the original data file and the sorted file,
and it will check the order of all the records in the sorted file.  

For the PennySort competition, we suggest all entrants use the same order as you use 
"SORT /L "C" <input> /O <output>" in Windows NT/2000/XP. If you simply use stricmp(), you will get 
this order, and it will follow this sequence:
!"#$%&'()*+,-./0123456789:;<=>?@[\]^_`AaBbCcdDeEFfGgHhiIjJKkLlMmnNoOpPqQrRSstTUuVvwWXxYyZz{|}~

This is a console application. It has been compiled with Visual C++.Net and tested in Window XP.

This is the command syntax:

ChkSort   <filename1>   <filename2>

<filename1> is the input file generated by SortGen.
<filename2> is your sorted output file of <filename1>.

History:
Peng Liu    12/08/02    Created.

Limitations:
ChkSort puts no limitations on the length of files, but records must be exactly 100-bytes long.

*/

//
//  INCLUDE FILES
//
    // 20080503, port to linux, yzf
//#include "stdafx.h"
#include   <stdio.h>
#include   <stdlib.h>
#include <string.h>

#define  VERSION    "V1.0"

//
// GLOBALS
//
const   int RecordSize          = 100;                              // 100 bytes
const   int UnitsPerRecord      = RecordSize/sizeof(unsigned long);
// Since GetCheckSum() use unsigned long to calculate checksum,
// RecordSize must be exactly multiple of sizeof(unsigned long).
const   int RecordsPerBuffer    = 1<<16;                            // 64 K records per buffer
const   int BufferSize          = RecordSize * RecordsPerBuffer;    // 6400KB buffer size

char    *Buffer  ;                  // file buffer    
char    *FileName1;                 // the file before sort 
char    *FileName2;                 // the file after sort


/*************************************************************************
*                                                                        *
* Online manual                                                      *
*                                                                        *
*************************************************************************/
void usage()
{
    fprintf(stderr,"\nUsage: ChkSort <filename1> <filename2> \n");
    fprintf(stderr,"      <filename1> is the input file generated by SortGen \n");
    fprintf(stderr,"      <filename2> is your sorted output file of <filename1>\n");
}

/***************************************************************************
*                                                                          *
*   Check whether the length of records in file is exactly 100 bytes.      *
*                                                                          *
***************************************************************************/
bool CheckRecordLen(FILE *file, char *filename)
{
    size_t RecordLen = 0;               // length of a record

    if (fgets(Buffer, BufferSize, file)==NULL)      // read a record from the file
    {
        fprintf(stderr,"\nError reading file %s\n", filename) ;
        return false;
    } else
    {
        RecordLen=strlen(Buffer);           // test its length
        if (RecordLen!=RecordSize)
        {
            fprintf(stderr,"\nThe size of records in file %s is %d (not exactly %d bytes long.)\n", filename, RecordLen, RecordSize) ;
            return false;
        } else
            fseek(file, 0, SEEK_SET);       // roll back the file pointer
    }
    return true;
}

/*************************************************************************
*                                                                        *
*   Read a block from file to fill up the buffer.                        *
*                                                                        *
*************************************************************************/
long ReadToBuffer(FILE *file)
{   
    long RecordCount = 0;           // the number of records read out from the file
    RecordCount = (long)fread( Buffer, RecordSize, RecordsPerBuffer, file);
    return (RecordCount);
}

/*************************************************************************
*                                                                        *
*   Calculate the checksum of all the records in the buffer.             *
*                                                                        *
*************************************************************************/
unsigned long GetCheckSum(long NumRecords)
{   
    unsigned long checksum = 0;     // checksum of all the records in the buffer
    unsigned long *plong = (unsigned long *)Buffer;
    // dynamic pointer to each unsigned long value in the buffer
    fprintf(stderr,".");            // display information of one step processing
    for (long i=0; i<NumRecords; i++)
        for (long j=0; j<UnitsPerRecord; j++)
        {
            checksum+=(unsigned long)(*plong);      // get a checksum by adding every 4-bytes unsigned value
            plong++;                // points to next unsigned long value
        }
        return (checksum);
}

/*************************************************************************
*                                                                        *
*   Tell whether two griven records follow the desired order.            *
*   If not, give error message.                                          *
*                                                                        *
*************************************************************************/
bool Compare(char *record1, char *record2)
{
    int result;                     // return value of strnicmp()
    bool ordersign;                 // sign of whether record1<=record2

    //result=strnicmp(record1,record2,RecordSize);
    // use memcpy instead, the same as SortKeyComp
    result=memcmp(record1,record2,RecordSize);
    if (result<=0)
    {
        ordersign=true;
    } else
    {
        ordersign=false;
        record1[RecordSize-1]=0;    // to ensure the end of the record is zero
        record2[RecordSize-1]=0;
        fprintf(stderr,"\n\nBad News -- Disorder in file %s:\n%s\n%s\n",FileName2, record1, record2);
    }
    return ordersign;
}

/*************************************************************************
*                                                                        *
* Verify the order  of all the records in the buffer.                    *
*                                                                        *
*************************************************************************/
bool VerifyOrder(char *LastRecord, int RecordsNum)      
{
    bool ordersign=true;        // sign of whether all the records in the buffer follow the order 
    ordersign = Compare(LastRecord, &Buffer[0]);
    // Compare the last record in the previous buffer content with the first record of the new buffer content
    if (ordersign)
    {
        for (long i=0; i<RecordsNum-1; i++)
        {
            ordersign= Compare(&Buffer[i*RecordSize],&Buffer[(i+1)*RecordSize]);
            // compare the order of two adjoining records
            if (!ordersign)
                break;
        }
        memmove(LastRecord,&Buffer[(RecordsNum-1)*RecordSize],RecordSize);
        // save the last record in the buffer to LastRecord
    }
    return ordersign;
}


/*************************************************************************
*                                                                        *
* Main  routine of checking process                                      *
*                                                                        *
*************************************************************************/

main (int argc, char * argv[])
{
    FILE        * File1, * File2 ;          // the input file and output file of sorting
    long        BufferRecords    = 0;       // number of records in buffer
    long        error            = 0;       // error flag
    long        RecordNum1       = 0;       // total record number in file1
    long        RecordNum2       = 0;       // total record number in file2
    unsigned long CheckSum1      = 0;       // checksum of file1
    unsigned long CheckSum2      = 0;       // checksum of file2
    char        LastRecord[RecordSize];     // a copy of the last record in the buffer
    bool        OrderSign        = true;    // sign of whether all the records in the file have the desired order 

    /************************************************************************
    *                                                                       *
    *       Put out greeting                                                *
    *                                                                       *
    ************************************************************************/
    fprintf(stderr,"ChkSort (%s) - Verify your PennySort result with its checksum and order.", VERSION);
    fprintf(stderr,"\n    Author: Peng Liu, Tsinghua University, China.  pengliu@ieee.org  12/2002\n");

    /*********************************************************************
    *                                                                    *
    *       Decode parameters                                            *
    *                                                                    *
    *********************************************************************/
    if (argc != 3)
    { usage(); error = 1; goto common_exit; }
    FileName1=argv[1];
    FileName2=argv[2];

    /************************************************************************/
    /*                                                                      */
    /*      Allocate file buffer                                            */
    /*                                                                      */
    /************************************************************************/
    Buffer = (char *)malloc( BufferSize ) ;
    if( Buffer  == NULL  )
    {
        fprintf(stderr,"\nCouldn't allocate the I/O buffer\n");
        error = 1;  goto common_exit;
    }

    /************************************************************************/
    /*                                                                      */
    /*      Calculate checksum of <filename1>                               */
    /*                                                                      */
    /************************************************************************/

    fprintf(stderr,"\nAnalysing file: %s \n", FileName1);

    // open <filename1>
    File1 = fopen( FileName1, "r+b");
    if( File1 == NULL )
    {
        fprintf(stderr,"\nError opening file %s\n", FileName1) ;
        error = 1;  goto common_exit;
    }

    // check whether the record length in <filename1> is exactly 100 bytes long
    if (CheckRecordLen(File1, FileName1)==false)
    {
        error = 1;  goto common_exit;
    }

    // count the total number of records and calculate its checksum
    RecordNum1=0;
    while ((BufferRecords=ReadToBuffer(File1)) !=0)
    {
        RecordNum1 += BufferRecords;
        CheckSum1 += GetCheckSum(BufferRecords);
    }
    fclose(File1);

    // tell the user about its record number and checksum
    fprintf(stderr, "\nRecord Number: %d  Checksum: %lX\n",RecordNum1, CheckSum1);

    /************************************************************************/
    /*                                                                      */
    /*      Calculate checksum and check order of <filename2>               */
    /*                                                                      */
    /************************************************************************/

    fprintf(stderr,"\n\nAnalysing file: %s \n", FileName2);

    // open <filename2>
    File2 = fopen( FileName2, "r+b");
    if( File2 == NULL )
    {
        fprintf(stderr,"\nError opening file %s\n", FileName2) ;
        error = 1;  goto common_exit;
    }

    // check whether the record length in <filename2> is exactly 100 bytes long
    if (CheckRecordLen(File2, FileName2)==false)
    {
        error = 1;  goto common_exit;
    }

    // count the number of records and checksum of <filename2>
    // and check the order of records in <filename2> one by one
    RecordNum2=0;
    LastRecord[0]=0;
    while ((BufferRecords=ReadToBuffer(File2)) !=0)
    {
        OrderSign=VerifyOrder(LastRecord, BufferRecords);
        // Compare the last record of previous buffer content with the first record of this one
        if (!OrderSign)
            break;
        RecordNum2 += BufferRecords;
        CheckSum2 += GetCheckSum(BufferRecords);
    }
    fclose(File2);
    if (!OrderSign)     // if the order of the records is not correct
        goto common_exit;

    // tell the user about its record number and checksum
    fprintf(stderr, "\nRecord Number: %d  Checksum: %lX\n",RecordNum2, CheckSum2);

    /************************************************************************/
    /*                                                                      */
    /*      Put out result message of comparing checksum and order          */
    /*                                                                      */
    /************************************************************************/

    if (CheckSum1==CheckSum2)
        fprintf(stderr, "\n\nCongratulations: Verification Passed!\n");
    else
        fprintf(stderr, "\n\nBad News: Verification failed due to different checksums \n(although order of records are correct)!\n");

    /************************************************************************/
    /*                                                                      */
    /*      All Done                                                        */
    /*      close output file; and exit                                     */
    /*                                                                      */
    /************************************************************************/

common_exit:
    free(Buffer);                       // free record buffer
    return(error);                      // return status code
}                                       // End of ChkSort.cpp
